/*Copyright (c) 2010 Alan Jhonnes - alanjhonnes@hotmail.com - ajwebdesign.com.brPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*/package br.com.ajwebdesign.ui.fluidlayout {	import com.gaiaframework.assets.DisplayObjectAsset;	import flash.display.BitmapData;	import flash.display.Stage;	import flash.events.Event;	import flash.display.DisplayObject;	import com.greensock.TweenNano;	import com.greensock.easing.Quad;	import com.greensock.easing.Strong;	import flash.geom.Rectangle;	import temple.core.CoreObject;		/**	 * Fluid Object class to snap display objects on the stage.	 * @author Alan Jhonnes	 * @version 2.0	 */	public class FluidObject extends CoreObject  {		protected var _offsetX:Number;		protected var _offsetY:Number;		protected var _alignment:String;		protected var _target:DisplayObject;		protected var _stage:Stage;		protected var _ease:Boolean;		public var duration:Number;		private var locked:Boolean;		private var _calculateVisible:Boolean;		private var stgXRatio:Number;		private var stgYRatio:Number;		private var targetXAlign:Number;		private var targetYAlign:Number;		protected var _minX:Number;		protected var _minY:Number;		protected var _bd:BitmapData;		protected var _referenceObject:DisplayObject;				protected var stageW:Number;		protected var stageH:Number;		protected var targetW:Number;		protected var targetH:Number;				public var useMinimun:Boolean = false;				/** Destroys this object */		override public function destruct():void {			_offsetX = NaN;			_offsetY = NaN;			_alignment = null;			_target = null;			if (_stage) {				_stage.removeEventListener(Event.RESIZE, onStageResize);				_stage = null;			}			_ease = false;			duration = NaN;			locked = false;			_calculateVisible = false;			_minX = NaN;			_minY = NaN;			_referenceObject = null;			if (_bd) {				_bd.dispose();				_bd = null;			}			super.destruct();		}		/**		 * Aligns an object.		 * @param	target The object to be aligned.		 * @param	alignment The alignment.Use the Alignment class constants for this.		 * @param	offsetX The horizontal offset.		 * @param	offsetY The vertical offset.		 * @param   minX Minimun X position		 * @param   minY Minimun Y position		 * @param   calculateVisible Wheter to calculate the bounds of the object based on the part visible. Enable on when necessary as it is processor intensive.		 * @param 	ease Turn easing on/off.		 * @param 	easeDuration The duration of the easing effect.		 */		public function FluidObject(target:DisplayObject,alignment:String = "MIDDLE", offsetX:Number = 0,offsetY:Number=0, minX:Number = 0, minY:Number = 0, calculateVisible:Boolean = false, ease:Boolean = false, easeDuration:Number = 0.3, referenceObject:DisplayObject = null) {			/* Assign the instance variables */			_target = target;			_stage = target.stage;			_offsetX = offsetX;			_offsetY = offsetY;			_ease = ease;			_minX = minX;			_minY = minY;			_calculateVisible = calculateVisible;						/* get the current width and height of the flash document */			var stageW:int = _stage.stageWidth;			var stageH:int = _stage.stageHeight;			if (_calculateVisible) {				_bd = new BitmapData(2800, 2800, true, 0x00FFFFFF);			}			this.duration = easeDuration;			if (!referenceObject) {				_referenceObject = _target;			}			else {				_referenceObject = referenceObject;			}			targetW = _referenceObject.width;			targetH = _referenceObject.height;			_alignment = alignment;			calculateRatios();			_stage.addEventListener(Event.RESIZE, onStageResize);			onStageResize();		}				/* Function that reposition the monitored object */		public function align():void {						var newX:Number;			var newY:Number;			if (!_calculateVisible) {				//targetW = _target.width;				//targetH = _target.height;			}			else {				var _rect:Rectangle = new Rectangle(0, 0, _referenceObject.width, _referenceObject.height);				_bd.fillRect(_rect, 0x00FFFFFF);				_bd.draw(_referenceObject);				var bounds:Rectangle = _bd.getColorBoundsRect(0xFF000000, 0x00000000, false);				targetW = bounds.width;				targetH = bounds.height;			}						newX = (stageW * stgXRatio) + targetXAlign + _offsetX;			newY = (stageH * stgYRatio) + targetYAlign + _offsetY;						if (useMinimun) {				if (newX < _minX) {					newX = _minX;				}				if (newY < _minY) {					newY = _minY;				}			}						if (_ease == true) {				TweenNano.to(_target, duration, { x:newX, y:newY, ease:Strong.easeOut });			}			else {				_target.x = newX;				_target.y = newY;			}		}				protected function onStageResize(e:Event = null):void {			if (locked == false) {				/* get the current width and height of the flash document */				stageW = _stage.stageWidth;				stageH = _stage.stageHeight;					align();			}		}				protected function calculateRatios():void {			switch (_alignment){				case "TOP_LEFT":					stgXRatio = 0;					stgYRatio = 0;					targetXAlign = 0;					targetYAlign = 0;				break;				case "TOP":					stgXRatio = 0.5;					stgYRatio = 0;					targetXAlign = -targetW >> 1;					targetYAlign = 0				break;				case "TOP_RIGHT":					stgXRatio = 1;					stgYRatio = 0;					targetXAlign = -targetW;					targetYAlign = 0				break;				case "LEFT":					stgXRatio = 0;					stgYRatio = 0.5;					targetXAlign = 0;					targetYAlign = -targetH >> 1;				break;				case "MIDDLE":					stgXRatio = 0.5;					stgYRatio = 0.5;					targetXAlign = -targetW >> 1;					targetYAlign = -targetH >> 1;				break;				case "RIGHT":					stgXRatio = 1;					stgYRatio = 0.5;					targetXAlign = -targetW;					targetYAlign = -targetH >> 1;				break;				case "BOTTOM_LEFT":					stgXRatio = 0;					stgYRatio = 1;					targetXAlign = 0;					targetYAlign = -targetH;				break;				case "BOTTOM":					stgXRatio = 0.5;					stgYRatio = 1;					targetXAlign = -targetW >> 1;					targetYAlign = -targetH;				break;				case "BOTTOM_RIGHT":					stgXRatio = 1;					stgYRatio = 1;					targetXAlign = -targetW;					targetYAlign = -targetH;				break;			}		}				/**		 * Stops realigning the object		 */		public function lock():void {			locked = true;		}				/**		 * Unlocks the object,realigning it on resize		 */		public function unlock():void {			locked = false;		}				public function get offsetX():Number { return _offsetX; }				public function set offsetX(value:Number):void 		{			_offsetX = value;			this.align();		}				public function get offsetY():Number { return _offsetY; }				public function set offsetY(value:Number):void 		{			_offsetY = value;			align();		}				public function get ease():Boolean { return _ease; }				public function set ease(value:Boolean):void {			_ease = value;		}				public function get calculateVisible():Boolean { return _calculateVisible; }				public function set calculateVisible(value:Boolean):void {			_calculateVisible = value;			if (_calculateVisible) {				_bd = new BitmapData(2800, 2800, true, 0x00FFFFFF);			}			else if(_bd) {				_bd.dispose();				_bd = null;			}		}				//returns visible width		public function get visibleWidth():Number {			var _rect:Rectangle = new Rectangle(0, 0, _referenceObject.width, _referenceObject.height);			if (_bd == null) {				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			else {				_bd.dispose();				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			_bd.fillRect(_rect, 0x00FFFFFF);			_bd.draw(_referenceObject);			return _bd.getColorBoundsRect(0xFF000000, 0x00000000, false).width;		}				//returns visible height		public function get visibleHeight():Number {			var _rect:Rectangle = new Rectangle(0, 0, _referenceObject.width, _referenceObject.height);			if (_bd == null) {				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			else {				_bd.dispose();				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			_bd.fillRect(_rect, 0x00FFFFFF);			_bd.draw(_referenceObject);			return _bd.getColorBoundsRect(0xFF000000, 0x00000000, false).height;		}				public function get visibleX():Number {			var _rect:Rectangle = new Rectangle(0, 0, _referenceObject.width, _referenceObject.height);			if (_bd == null) {				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			else {				_bd.dispose();				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			_bd.fillRect(_rect, 0x00FFFFFF);			_bd.draw(_referenceObject);			return _bd.getColorBoundsRect(0xFF000000, 0x00000000, false).x;		}				public function get visibleY():Number {			var _rect:Rectangle = new Rectangle(0, 0, _referenceObject.width, _referenceObject.height);			if (_bd == null) {				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			else {				_bd.dispose();				_bd = new BitmapData(_referenceObject.width, _referenceObject.height, true, 0x00FFFFFF);			}			_bd.fillRect(_rect, 0x00FFFFFF);			_bd.draw(_referenceObject);			return _bd.getColorBoundsRect(0xFF000000, 0x00000000, false).y;		}						public function get referenceObject():DisplayObject {			return _referenceObject;		}				public function set referenceObject(value:DisplayObject):void {			if (value == null) {				_referenceObject = _target;			}			else {				_referenceObject = value;			}			targetW = _referenceObject.width;			targetH = _referenceObject.height;			align();		}				public function get alignment():String {			return _alignment;		}				public function set alignment(value:String):void {			_alignment = value;			calculateRatios();			align();		}	}	}